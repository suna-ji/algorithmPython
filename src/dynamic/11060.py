# 점프점프
# 1 X N 크기의 미로에 갇혀있다.
# 각 칸에는 정수가 쓰여져 있고 해당 정수이하 만큼 오른쪽으로 이동이 가능하다.
# 재환이는 현재 가장 왼쪽 끝에 있고 오른쪽 끝으로 가려한다.
# 최소 몇번의 점프를 해야 갈 수 있을 지 구하자. 갈 수 없다면 -1을 출력.
# 기본적인 다이나믹 문제라고 함
# 다이나믹 프로그래밍 문제의 조건
# 1) 최적 부분 구조 : 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다
# 2) 중복되는 부분 문제 : 동일한 작은 문제를 반복적으로 해결할 수 있다.

n = int(input())
graph = list(map(int, input().split()))

dp = [n + 1] * n # 최대값으로 초기화
dp[0] = 0 # 가장 왼쪽 칸은 출발칸이므로 0으로 초기화

for i in range(n):
    for j in range(1, graph[i] + 1):
        if i + j >= n:
            break
        dp[i + j] = min(dp[i + j] , dp[i] + 1)

if dp[n-1] > n:
    print(-1)
else:
    print(dp[n-1])